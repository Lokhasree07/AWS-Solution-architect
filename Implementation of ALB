To implement an AWS Application Load Balancer (ALB) to efficiently distribute HTTP/HTTPS traffic across EC2 instances while improving fault tolerance and performance.
1) High-level architecture (recommended)

Internet → ALB (public) in at least 2 AZs → EC2 targets (in private subnets) across the same AZs.

ALB handles TLS termination, path/host-based routing, health checks, and exposes X-Forwarded-* headers to backends.

Add Auto Scaling Group(s) for EC2 targets, WAF for protection, CloudFront if you need global caching, and CloudWatch + S3 access logs for observability.


2) Step-by-step implementation (Console & CLI notes)
A. Networking & subnets

Create a VPC if you don’t have one.

Create public subnets in 2+ AZs for the ALB.

Create private subnets in same AZs for EC2 instances (recommended).

Ensure route tables and NAT Gateway (if instances need internet access for updates).

B. Security groups

ALB SG (allow inbound):

TCP 80 (HTTP) from 0.0.0.0/0 (or restrict as needed)

TCP 443 (HTTPS) from 0.0.0.0/0

EC2 SG (allow inbound from ALB SG):

TCP 80/443 (or your app port) from the ALB security group (use SG-id as source)

Egress: as required (usually 0.0.0.0/0 for ALB and instances)

C. TLS / Certificates

Request or import an SSL/TLS certificate in AWS Certificate Manager (ACM) in the region where ALB lives.

Use ACM cert for ALB listener (ACM-managed certs terminate on ALB — easiest and secure).

D. Create Target Group(s)

Type: instance (targets are EC2 instances) or ip for IP targets (ECS, etc).

Protocol: HTTP or HTTPS (often HTTP if ALB handles TLS).

Health check: Path /health (or app-specific), Protocol HTTP, Port traffic port.
Recommended health-check settings (tune to app):

Interval: 30s

Timeout: 5s

Healthy threshold: 3

Unhealthy threshold: 2

Register instances (or let Auto Scaling register them).

E. Create ALB

Scheme: internet-facing for public web traffic.

Subnets: choose the public subnets across AZs.

Attach the ALB security group.

Enable Cross-Zone Load Balancing (ALB supports it automatically; verify).

F. Create Listeners & Listener Rules

Listener 80 (HTTP): configure a rule to redirect all HTTP → HTTPS (301). Keeps security posture.

Listener 443 (HTTPS): attach ACM cert; forward to one or multiple target groups.

Use host-based and path-based rules to route different services to different target groups.

G. Register Targets / Autoscaling

Register the EC2 instances with target group(s), or attach the Auto Scaling Group to the target group so instances are auto-registered/deregistered.

Configure Auto Scaling with metrics (CPU, request count per target, custom metrics) to scale based on load.

3) Performance & fault tolerance best practices

Multiple AZs: Always put ALB and targets across 2+ AZs to avoid single-AZ failure.

Health checks: Use an efficient health endpoint that checks app liveness (not heavy DB queries) so unhealthy hosts are removed quickly.

Deregistration delay: Default is 300s; reduces request loss during scale-in. Tune based on in-flight request lifetime (e.g., 30–300s).

Keep-alive / idle timeouts: ALB default idle timeout is 60s — increase for long-polling or WebSocket apps.

HTTP/2 & gRPC: ALB supports HTTP/2 to clients — enable it to improve multiplexing (ALB→backend uses HTTP/1.1/HTTP/2 depending on config).

Connection reuse: ALB reuses connections to targets; ensure back-end apps handle keep-alive efficiently.

Cross-zone load balancing: ALB evenly distributes across AZs. Confirm enabled.

Sticky sessions: Use target-group stickiness only when necessary (e.g., legacy sessions). Prefer stateless app & distributed session store (Redis, DynamoDB).

Buffering & timeouts: Make sure back-end servers have proper request-queue buffers; tune app server timeouts to be shorter than ALB idle timeout to avoid dropped connections.

Scale vertically & horizontally: Use instance sizing for CPU/memory-bound workloads and autoscaling for traffic spikes.

4) Security & resilience

TLS policy: use AWS managed TLS policy which supports TLS 1.2/1.3; disable old ciphers.

WAF: place AWS WAF on ALB to block common attacks (SQLi, XSS, IP blocklist).

Shield / DDoS: use Shield Advanced for high-value endpoints (optional).

Access logs: enable ALB access logs (S3) for traffic analysis and audit.

Monitoring & alarms (CloudWatch): monitor RequestCount, HTTPCode_ELB_5XX, TargetResponseTime, HealthyHostCount. Set alarms to trigger scaling or paging.

IAM least privilege: for services interacting with ALB resources.

5) Observability & troubleshooting

CloudWatch metrics + dashboards: track latency, request count, 5xx/4xx rates.

Access logs: store and analyze in S3 + Athena or use ELK for deeper analysis.

X-Forwarded-For / X-Forwarded-Proto: ensure app consumes these headers for client IP and original protocol.

Target health: when an instance fails health checks, check app logs, security group, and OS-level metrics.

6) Extra optimizations (optional but recommended)

CloudFront in front of ALB for caching, TLS offload at edge, and DDoS protection.

HTTP compressions (gzip, brotli) at ALB is not available — implement compression in app or via CloudFront.

Use multiple target groups for blue/green deployments, canary releases (shift % traffic using weighted target groups / listener rules).

Use ALB evaluation for WebSockets — ALB supports WebSocket and HTTP/2 (ensure idle timeout > expected websocket idle time).

7) Quick AWS CLI example (minimal, replace placeholders)
# 1) Create target group
aws elbv2 create-target-group \
  --name my-tg \
  --protocol HTTP \
  --port 80 \
  --vpc-id vpc-xxxx \
  --health-check-protocol HTTP \
  --health-check-path /health

# 2) Create ALB (internet-facing)
aws elbv2 create-load-balancer \
  --name my-alb \
  --subnets subnet-aaa subnet-bbb \
  --security-groups sg-ALB

# 3) Register instances (example)
aws elbv2 register-targets --target-group-arn <tg-arn> --targets Id=i-aaa Id=i-bbb

# 4) Create HTTPS listener (assumes certificate ARN)
aws elbv2 create-listener \
  --load-balancer-arn <alb-arn> \
  --protocol HTTPS \
  --port 443 \
  --certificates CertificateArn=arn:aws:acm:... \
  --default-actions Type=forward,TargetGroupArn=<tg-arn>

# 5) Create HTTP listener that redirects to HTTPS
aws elbv2 create-listener \
  --load-balancer-arn <alb-arn> \
  --protocol HTTP \
  --port 80 \
  --default-actions Type=redirect,RedirectConfig='{"Protocol":"HTTPS","Port":"443","StatusCode":"HTTP_301"}'


(Use Auto Scaling attachment to auto-register instances rather than manual registration.)

8) Suggested default values you can start with

Health check: GET /health, interval 30s, timeout 5s, healthy 3, unhealthy 2.

Deregistration delay: 120s (increase for longer in-flight work).

Idle timeout: 60s (raise to 350+ for WebSockets).

Stickiness: off by default; enable with TTL 1 day only if required.

9) Checklist before going live

 ALB in ≥2 AZs and targets across AZs

 TLS cert in ACM and redirect HTTP→HTTPS

 Health checks return success quickly and reliably

 Security groups only allow ALB → EC2 on app port

 Auto Scaling configured and tested with load test

 Access logging & CloudWatch alerts enabled

 WAF rules (if required) and TLS policy hardened
